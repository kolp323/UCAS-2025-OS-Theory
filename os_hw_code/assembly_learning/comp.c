#include <stdio.h>

int my_var = 50;
int main(int argc, char **argv)
{
    asm volatile(
        "compl %1, %0;"  
        : // 比较指令没有输出
        : "r"(my_var), "i"(100)      
        : "cc"                 // ! 该指令会修改标志寄存器
// 另一个非常重要的被修改项是 "memory"。如果你在汇编代码里修改了内存，
// 但又没有通过输出操作数告诉编译器，你就必须在这里加上 "memory"。
// 它会强制编译器在执行汇编代码前，把所有缓存在寄存器里的变量都存回内存，执行完后再重新加载。

// 因为对于一个变量x，编译器认为它的最新值就是寄存器中的值，但内联汇编直接修改了x实际在内存中的值
// 但没有更新寄存器中的值，那么汇编结束后编译器继续使用寄存器中的旧值，就会出错。
    );
    return 0;
}